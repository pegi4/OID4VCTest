import { Status } from './ConstraintUtils';
import { EvaluationClientWrapper } from './evaluation';
import { PresentationSubmissionLocation } from './signing';
import { PEVersion, SSITypesBuilder } from './types';
import { definitionVersionDiscovery } from './utils';
import { PresentationDefinitionV1VB, PresentationDefinitionV2VB, PresentationSubmissionVB, ValidationEngine } from './validation';
/**
 * This is the main interfacing class to be used by developers using the PEX library.
 */
export class PEX {
    _evaluationClientWrapper;
    constructor() {
        // TODO:  So we have state in the form of this property which is set in the constructor, but we are overwriting it elsewhere. We need to retrhink how to instantiate PEX
        this._evaluationClientWrapper = new EvaluationClientWrapper();
    }
    /***
     * The evaluatePresentation compares what is expected from a presentation with a presentationDefinition.
     * presentationDefinition: It can be either v1 or v2 of presentationDefinition
     *
     * @param presentationDefinition the definition of what is expected in the presentation.
     * @param presentation the presentation which has to be evaluated in comparison of the definition.
     * @param opts - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
     *
     * @return the evaluation results specify what was expected and was fulfilled and also specifies which requirements described in the input descriptors
     * were not fulfilled by the presentation.
     */
    evaluatePresentation(presentationDefinition, presentation, opts) {
        const generatePresentationSubmission = opts?.generatePresentationSubmission !== undefined ? opts.generatePresentationSubmission : opts?.presentationSubmission !== undefined;
        const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        const presentationCopy = JSON.parse(JSON.stringify(presentation));
        const wrappedPresentation = SSITypesBuilder.mapExternalVerifiablePresentationToWrappedVP(presentationCopy);
        const presentationSubmission = opts?.presentationSubmission || wrappedPresentation.presentation.presentation_submission;
        if (!presentationSubmission && !generatePresentationSubmission) {
            throw Error(`Either a presentation submission as part of the VP or provided separately was expected`);
        }
        const holderDIDs = wrappedPresentation.presentation.holder ? [wrappedPresentation.presentation.holder] : [];
        const updatedOpts = {
            ...opts,
            holderDIDs,
            presentationSubmission,
            generatePresentationSubmission,
        };
        const result = this._evaluationClientWrapper.evaluate(pd, wrappedPresentation.vcs, updatedOpts);
        if (result.value && result.value.descriptor_map.length) {
            const selectFromClientWrapper = new EvaluationClientWrapper();
            const selectResults = selectFromClientWrapper.selectFrom(pd, wrappedPresentation.vcs, updatedOpts);
            if (selectResults.areRequiredCredentialsPresent !== Status.ERROR) {
                result.errors = [];
            }
        }
        return result;
    }
    /***
     * The evaluate compares what is expected from a verifiableCredentials with the presentationDefinition.
     *
     * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
     * @param verifiableCredentials the verifiable credentials which are candidates to fulfill requirements defined in the presentationDefinition param.
     * @param opts - holderDIDs the list of the DIDs that the wallet holders controls. Optional, but needed by some input requirements that do a holderDID check.
     * @           - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
     *
     * @return the evaluation results specify what was expected and was fulfilled and also specifies which requirements described in the input descriptors
     * were not fulfilled by the verifiable credentials.
     */
    evaluateCredentials(presentationDefinition, verifiableCredentials, opts) {
        const wrappedVerifiableCredentials = SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(verifiableCredentials);
        // TODO:  So we have state in the form of this property which is set in the constructor, but we are overwriting it here. We need to retrhink how to instantiate PEX
        this._evaluationClientWrapper = new EvaluationClientWrapper();
        const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        const result = this._evaluationClientWrapper.evaluate(pd, wrappedVerifiableCredentials, opts);
        if (result.value && result.value.descriptor_map.length) {
            const selectFromClientWrapper = new EvaluationClientWrapper();
            const selectResults = selectFromClientWrapper.selectFrom(pd, wrappedVerifiableCredentials, opts);
            result.areRequiredCredentialsPresent = selectResults.areRequiredCredentialsPresent;
        }
        else {
            result.areRequiredCredentialsPresent = Status.ERROR;
        }
        return result;
    }
    /**
     * The selectFrom method is a helper function that helps filter out the verifiable credentials which can not be selected and returns
     * the selectable credentials.
     *
     * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
     * @param verifiableCredentials verifiable credentials are the credentials from wallet provided to the library to find selectable credentials.
     * @param opts - holderDIDs the decentralized identifier(s) of the wallet holderDID. This is used to identify the credentials issued to the holderDID of wallet in certain scenario's.
     *             - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
     *
     * @return the selectable credentials.
     */
    selectFrom(presentationDefinition, verifiableCredentials, opts) {
        const verifiableCredentialCopy = JSON.parse(JSON.stringify(verifiableCredentials));
        const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        // TODO:  So we have state in the form of this property which is set in the constructor, but we are overwriting it here. We need to retrhink how to instantiate PEX
        this._evaluationClientWrapper = new EvaluationClientWrapper();
        return this._evaluationClientWrapper.selectFrom(pd, SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(verifiableCredentialCopy), opts);
    }
    presentationSubmissionFrom(presentationDefinition, selectedCredentials) {
        const pd = SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        return this._evaluationClientWrapper.submissionFrom(pd, SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(selectedCredentials));
    }
    /**
     * This method helps create an Unsigned Presentation. An Unsigned Presentation after signing becomes a Presentation. And can be sent to
     * the verifier after signing it.
     *
     * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
     * @param selectedCredentials the credentials which were declared selectable by getSelectableCredentials and then chosen by the intelligent-user
     * (e.g. human).
     * @param opts? - holderDID optional; the decentralized identity of the wallet holderDID. This is used to identify the holderDID of the presentation.
     *
     * @return the presentation.
     */
    presentationFrom(presentationDefinition, selectedCredentials, opts) {
        const presentationSubmissionLocation = opts?.presentationSubmissionLocation ?? PresentationSubmissionLocation.PRESENTATION;
        const presentationSubmission = this.presentationSubmissionFrom(presentationDefinition, selectedCredentials);
        const presentation = PEX.constructPresentation(selectedCredentials, {
            ...opts,
            presentationSubmission: presentationSubmissionLocation === PresentationSubmissionLocation.PRESENTATION ? presentationSubmission : undefined,
        });
        return {
            presentation,
            presentationSubmissionLocation,
            presentationSubmission,
        };
    }
    static constructPresentation(selectedCredentials, opts) {
        const holder = opts?.holderDID;
        const type = Array.isArray(opts?.basePresentationPayload?.type)
            ? opts?.basePresentationPayload?.type || []
            : opts?.basePresentationPayload?.type
                ? [opts.basePresentationPayload.type]
                : [];
        const context = opts?.basePresentationPayload?.['@context']
            ? Array.isArray(opts.basePresentationPayload['@context'])
                ? opts.basePresentationPayload['@context']
                : [opts.basePresentationPayload['@context']]
            : [];
        if (!context.includes('https://www.w3.org/2018/credentials/v1')) {
            context.push('https://www.w3.org/2018/credentials/v1');
        }
        if (!type.includes('VerifiablePresentation')) {
            type.push('VerifiablePresentation');
        }
        if (opts?.presentationSubmission) {
            if (!type.includes('PresentationSubmission')) {
                type.push('PresentationSubmission');
            }
            if (!context.includes('https://identity.foundation/presentation-exchange/submission/v1')) {
                context.push('https://identity.foundation/presentation-exchange/submission/v1');
            }
        }
        return {
            ...opts?.basePresentationPayload,
            '@context': context,
            type,
            holder,
            ...(!!opts?.presentationSubmission && { presentation_submission: opts.presentationSubmission }),
            verifiableCredential: (Array.isArray(selectedCredentials) ? selectedCredentials : [selectedCredentials]),
        };
    }
    /**
     * This method validates whether an object is usable as a presentation definition or not.
     *
     * @param presentationDefinition: presentationDefinition of V1 or v2 to be validated.
     *
     * @return the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation definition
     */
    static validateDefinition(presentationDefinition) {
        const result = definitionVersionDiscovery(presentationDefinition);
        if (result.error) {
            throw result.error;
        }
        const validators = [];
        result.version === PEVersion.v1
            ? validators.push({
                bundler: new PresentationDefinitionV1VB('root'),
                target: SSITypesBuilder.modelEntityToInternalPresentationDefinitionV1(presentationDefinition),
            })
            : validators.push({
                bundler: new PresentationDefinitionV2VB('root'),
                target: SSITypesBuilder.modelEntityInternalPresentationDefinitionV2(presentationDefinition),
            });
        return new ValidationEngine().validate(validators);
    }
    /**
     * This method validates whether an object is usable as a presentation submission or not.
     *
     * @param presentationSubmission the object to be validated.
     *
     * @return the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation submission
     */
    static validateSubmission(presentationSubmission) {
        return new ValidationEngine().validate([
            {
                bundler: new PresentationSubmissionVB('root'),
                target: presentationSubmission,
            },
        ]);
    }
    /**
     * This method can be used to combine a definition, selected Verifiable Credentials, together with
     * signing opts and a callback to sign a presentation, making it a Verifiable Presentation before sending.
     *
     * Please note that PEX has no signature support on purpose. We didn't want this library to depend on all kinds of signature suites.
     * The callback function next to the Signing Params also gets a Presentation which is evaluated against the definition.
     * It is up to you to decide whether you simply update the supplied partial proof and add it to the presentation in the callback,
     * or whether you will use the selected Credentials, Presentation definition, evaluation results and/or presentation submission together with the signature opts
     *
     * @param presentationDefinition the Presentation Definition V1 or V2
     * @param selectedCredentials the PEX and/or User selected/filtered credentials that will become part of the Verifiable Presentation
     * @param signingCallBack the function which will be provided as a parameter. And this will be the method that will be able to perform actual
     *        signing. One example of signing is available in the project named. pe-selective-disclosure.
     * @param opts: Signing Params these are the signing params required to sign.
     *
     * @return the signed and thus Verifiable Presentation.
     */
    async verifiablePresentationFrom(presentationDefinition, selectedCredentials, signingCallBack, opts) {
        const { holderDID, signatureOptions, proofOptions } = opts;
        const presentationSubmissionLocation = opts.presentationSubmissionLocation ?? PresentationSubmissionLocation.PRESENTATION;
        function limitedDisclosureSuites() {
            let limitDisclosureSignatureSuites = [];
            if (proofOptions?.typeSupportsSelectiveDisclosure) {
                if (!proofOptions?.type) {
                    throw Error('Please provide a proof type if you enable selective disclosure');
                }
                limitDisclosureSignatureSuites = [proofOptions.type];
            }
            return limitDisclosureSignatureSuites;
        }
        const holderDIDs = holderDID ? [holderDID] : [];
        const limitDisclosureSignatureSuites = limitedDisclosureSuites();
        const evaluationResult = this.evaluateCredentials(presentationDefinition, selectedCredentials, {
            holderDIDs,
            limitDisclosureSignatureSuites,
        });
        const presentationResult = this.presentationFrom(presentationDefinition, evaluationResult.verifiableCredential, {
            ...opts,
            presentationSubmissionLocation,
        });
        const evaluationResults = this.evaluatePresentation(presentationDefinition, presentationResult.presentation, { limitDisclosureSignatureSuites });
        if (!evaluationResults.value) {
            throw new Error('Could not get evaluation results from presentationResult');
        }
        const proof = {
            type: proofOptions?.type,
            verificationMethod: signatureOptions?.verificationMethod,
            created: proofOptions?.created ? proofOptions.created : new Date().toISOString(),
            proofPurpose: proofOptions?.proofPurpose,
            proofValue: signatureOptions?.proofValue,
            jws: signatureOptions?.jws,
            challenge: proofOptions?.challenge,
            nonce: proofOptions?.nonce,
            domain: proofOptions?.domain,
        };
        const callBackParams = {
            options: opts,
            presentation: presentationResult.presentation,
            presentationDefinition,
            selectedCredentials,
            proof,
            presentationSubmission: evaluationResults.value,
            evaluationResults,
        };
        const verifiablePresentation = await signingCallBack(callBackParams);
        return {
            verifiablePresentation,
            presentationSubmissionLocation,
            presentationSubmission: evaluationResults.value,
        };
    }
    static definitionVersionDiscovery(presentationDefinition) {
        return definitionVersionDiscovery(presentationDefinition);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUEVYLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL1BFWC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFZQSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDM0MsT0FBTyxFQUFFLHVCQUF1QixFQUFvQyxNQUFNLGNBQWMsQ0FBQztBQUV6RixPQUFPLEVBQTRDLDhCQUE4QixFQUFnQyxNQUFNLFdBQVcsQ0FBQztBQUNuSSxPQUFPLEVBQStFLFNBQVMsRUFBRSxlQUFlLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDbEksT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3JELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSwwQkFBMEIsRUFBRSx3QkFBd0IsRUFBYSxnQkFBZ0IsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUU3STs7R0FFRztBQUNILE1BQU0sT0FBTyxHQUFHO0lBQ0osd0JBQXdCLENBQTBCO0lBRTVEO1FBQ0Usd0tBQXdLO1FBQ3hLLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLHVCQUF1QixFQUFFLENBQUM7SUFDaEUsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxvQkFBb0IsQ0FDekIsc0JBQStDLEVBQy9DLFlBQTRELEVBQzVELElBTUM7UUFFRCxNQUFNLDhCQUE4QixHQUNsQyxJQUFJLEVBQUUsOEJBQThCLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsOEJBQThCLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxzQkFBc0IsS0FBSyxTQUFTLENBQUM7UUFDeEksTUFBTSxFQUFFLEdBQW9DLGVBQWUsQ0FBQyxnQ0FBZ0MsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQ3JILE1BQU0sZ0JBQWdCLEdBQW1DLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ2xHLE1BQU0sbUJBQW1CLEdBQWtD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