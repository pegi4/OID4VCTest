"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PEX = void 0;
const ConstraintUtils_1 = require("./ConstraintUtils");
const evaluation_1 = require("./evaluation");
const signing_1 = require("./signing");
const types_1 = require("./types");
const utils_1 = require("./utils");
const validation_1 = require("./validation");
/**
 * This is the main interfacing class to be used by developers using the PEX library.
 */
class PEX {
    constructor() {
        // TODO:  So we have state in the form of this property which is set in the constructor, but we are overwriting it elsewhere. We need to retrhink how to instantiate PEX
        this._evaluationClientWrapper = new evaluation_1.EvaluationClientWrapper();
    }
    /***
     * The evaluatePresentation compares what is expected from a presentation with a presentationDefinition.
     * presentationDefinition: It can be either v1 or v2 of presentationDefinition
     *
     * @param presentationDefinition the definition of what is expected in the presentation.
     * @param presentation the presentation which has to be evaluated in comparison of the definition.
     * @param opts - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
     *
     * @return the evaluation results specify what was expected and was fulfilled and also specifies which requirements described in the input descriptors
     * were not fulfilled by the presentation.
     */
    evaluatePresentation(presentationDefinition, presentation, opts) {
        const generatePresentationSubmission = (opts === null || opts === void 0 ? void 0 : opts.generatePresentationSubmission) !== undefined ? opts.generatePresentationSubmission : (opts === null || opts === void 0 ? void 0 : opts.presentationSubmission) !== undefined;
        const pd = types_1.SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        const presentationCopy = JSON.parse(JSON.stringify(presentation));
        const wrappedPresentation = types_1.SSITypesBuilder.mapExternalVerifiablePresentationToWrappedVP(presentationCopy);
        const presentationSubmission = (opts === null || opts === void 0 ? void 0 : opts.presentationSubmission) || wrappedPresentation.presentation.presentation_submission;
        if (!presentationSubmission && !generatePresentationSubmission) {
            throw Error(`Either a presentation submission as part of the VP or provided separately was expected`);
        }
        const holderDIDs = wrappedPresentation.presentation.holder ? [wrappedPresentation.presentation.holder] : [];
        const updatedOpts = Object.assign(Object.assign({}, opts), { holderDIDs,
            presentationSubmission,
            generatePresentationSubmission });
        const result = this._evaluationClientWrapper.evaluate(pd, wrappedPresentation.vcs, updatedOpts);
        if (result.value && result.value.descriptor_map.length) {
            const selectFromClientWrapper = new evaluation_1.EvaluationClientWrapper();
            const selectResults = selectFromClientWrapper.selectFrom(pd, wrappedPresentation.vcs, updatedOpts);
            if (selectResults.areRequiredCredentialsPresent !== ConstraintUtils_1.Status.ERROR) {
                result.errors = [];
            }
        }
        return result;
    }
    /***
     * The evaluate compares what is expected from a verifiableCredentials with the presentationDefinition.
     *
     * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
     * @param verifiableCredentials the verifiable credentials which are candidates to fulfill requirements defined in the presentationDefinition param.
     * @param opts - holderDIDs the list of the DIDs that the wallet holders controls. Optional, but needed by some input requirements that do a holderDID check.
     * @           - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
     *
     * @return the evaluation results specify what was expected and was fulfilled and also specifies which requirements described in the input descriptors
     * were not fulfilled by the verifiable credentials.
     */
    evaluateCredentials(presentationDefinition, verifiableCredentials, opts) {
        const wrappedVerifiableCredentials = types_1.SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(verifiableCredentials);
        // TODO:  So we have state in the form of this property which is set in the constructor, but we are overwriting it here. We need to retrhink how to instantiate PEX
        this._evaluationClientWrapper = new evaluation_1.EvaluationClientWrapper();
        const pd = types_1.SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        const result = this._evaluationClientWrapper.evaluate(pd, wrappedVerifiableCredentials, opts);
        if (result.value && result.value.descriptor_map.length) {
            const selectFromClientWrapper = new evaluation_1.EvaluationClientWrapper();
            const selectResults = selectFromClientWrapper.selectFrom(pd, wrappedVerifiableCredentials, opts);
            result.areRequiredCredentialsPresent = selectResults.areRequiredCredentialsPresent;
        }
        else {
            result.areRequiredCredentialsPresent = ConstraintUtils_1.Status.ERROR;
        }
        return result;
    }
    /**
     * The selectFrom method is a helper function that helps filter out the verifiable credentials which can not be selected and returns
     * the selectable credentials.
     *
     * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
     * @param verifiableCredentials verifiable credentials are the credentials from wallet provided to the library to find selectable credentials.
     * @param opts - holderDIDs the decentralized identifier(s) of the wallet holderDID. This is used to identify the credentials issued to the holderDID of wallet in certain scenario's.
     *             - limitDisclosureSignatureSuites the credential signature suites that support limit disclosure
     *
     * @return the selectable credentials.
     */
    selectFrom(presentationDefinition, verifiableCredentials, opts) {
        const verifiableCredentialCopy = JSON.parse(JSON.stringify(verifiableCredentials));
        const pd = types_1.SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        // TODO:  So we have state in the form of this property which is set in the constructor, but we are overwriting it here. We need to retrhink how to instantiate PEX
        this._evaluationClientWrapper = new evaluation_1.EvaluationClientWrapper();
        return this._evaluationClientWrapper.selectFrom(pd, types_1.SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(verifiableCredentialCopy), opts);
    }
    presentationSubmissionFrom(presentationDefinition, selectedCredentials) {
        const pd = types_1.SSITypesBuilder.toInternalPresentationDefinition(presentationDefinition);
        return this._evaluationClientWrapper.submissionFrom(pd, types_1.SSITypesBuilder.mapExternalVerifiableCredentialsToWrappedVcs(selectedCredentials));
    }
    /**
     * This method helps create an Unsigned Presentation. An Unsigned Presentation after signing becomes a Presentation. And can be sent to
     * the verifier after signing it.
     *
     * @param presentationDefinition the v1 or v2 definition of what is expected in the presentation.
     * @param selectedCredentials the credentials which were declared selectable by getSelectableCredentials and then chosen by the intelligent-user
     * (e.g. human).
     * @param opts? - holderDID optional; the decentralized identity of the wallet holderDID. This is used to identify the holderDID of the presentation.
     *
     * @return the presentation.
     */
    presentationFrom(presentationDefinition, selectedCredentials, opts) {
        var _a;
        const presentationSubmissionLocation = (_a = opts === null || opts === void 0 ? void 0 : opts.presentationSubmissionLocation) !== null && _a !== void 0 ? _a : signing_1.PresentationSubmissionLocation.PRESENTATION;
        const presentationSubmission = this.presentationSubmissionFrom(presentationDefinition, selectedCredentials);
        const presentation = PEX.constructPresentation(selectedCredentials, Object.assign(Object.assign({}, opts), { presentationSubmission: presentationSubmissionLocation === signing_1.PresentationSubmissionLocation.PRESENTATION ? presentationSubmission : undefined }));
        return {
            presentation,
            presentationSubmissionLocation,
            presentationSubmission,
        };
    }
    static constructPresentation(selectedCredentials, opts) {
        var _a, _b, _c, _d;
        const holder = opts === null || opts === void 0 ? void 0 : opts.holderDID;
        const type = Array.isArray((_a = opts === null || opts === void 0 ? void 0 : opts.basePresentationPayload) === null || _a === void 0 ? void 0 : _a.type)
            ? ((_b = opts === null || opts === void 0 ? void 0 : opts.basePresentationPayload) === null || _b === void 0 ? void 0 : _b.type) || []
            : ((_c = opts === null || opts === void 0 ? void 0 : opts.basePresentationPayload) === null || _c === void 0 ? void 0 : _c.type)
                ? [opts.basePresentationPayload.type]
                : [];
        const context = ((_d = opts === null || opts === void 0 ? void 0 : opts.basePresentationPayload) === null || _d === void 0 ? void 0 : _d['@context'])
            ? Array.isArray(opts.basePresentationPayload['@context'])
                ? opts.basePresentationPayload['@context']
                : [opts.basePresentationPayload['@context']]
            : [];
        if (!context.includes('https://www.w3.org/2018/credentials/v1')) {
            context.push('https://www.w3.org/2018/credentials/v1');
        }
        if (!type.includes('VerifiablePresentation')) {
            type.push('VerifiablePresentation');
        }
        if (opts === null || opts === void 0 ? void 0 : opts.presentationSubmission) {
            if (!type.includes('PresentationSubmission')) {
                type.push('PresentationSubmission');
            }
            if (!context.includes('https://identity.foundation/presentation-exchange/submission/v1')) {
                context.push('https://identity.foundation/presentation-exchange/submission/v1');
            }
        }
        return Object.assign(Object.assign(Object.assign(Object.assign({}, opts === null || opts === void 0 ? void 0 : opts.basePresentationPayload), { '@context': context, type,
            holder }), (!!(opts === null || opts === void 0 ? void 0 : opts.presentationSubmission) && { presentation_submission: opts.presentationSubmission })), { verifiableCredential: (Array.isArray(selectedCredentials) ? selectedCredentials : [selectedCredentials]) });
    }
    /**
     * This method validates whether an object is usable as a presentation definition or not.
     *
     * @param presentationDefinition: presentationDefinition of V1 or v2 to be validated.
     *
     * @return the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation definition
     */
    static validateDefinition(presentationDefinition) {
        const result = (0, utils_1.definitionVersionDiscovery)(presentationDefinition);
        if (result.error) {
            throw result.error;
        }
        const validators = [];
        result.version === types_1.PEVersion.v1
            ? validators.push({
                bundler: new validation_1.PresentationDefinitionV1VB('root'),
                target: types_1.SSITypesBuilder.modelEntityToInternalPresentationDefinitionV1(presentationDefinition),
            })
            : validators.push({
                bundler: new validation_1.PresentationDefinitionV2VB('root'),
                target: types_1.SSITypesBuilder.modelEntityInternalPresentationDefinitionV2(presentationDefinition),
            });
        return new validation_1.ValidationEngine().validate(validators);
    }
    /**
     * This method validates whether an object is usable as a presentation submission or not.
     *
     * @param presentationSubmission the object to be validated.
     *
     * @return the validation results to reveal what is acceptable/unacceptable about the passed object to be considered a valid presentation submission
     */
    static validateSubmission(presentationSubmission) {
        return new validation_1.ValidationEngine().validate([
            {
                bundler: new validation_1.PresentationSubmissionVB('root'),
                target: presentationSubmission,
            },
        ]);
    }
    /**
     * This method can be used to combine a definition, selected Verifiable Credentials, together with
     * signing opts and a callback to sign a presentation, making it a Verifiable Presentation before sending.
     *
     * Please note that PEX has no signature support on purpose. We didn't want this library to depend on all kinds of signature suites.
     * The callback function next to the Signing Params also gets a Presentation which is evaluated against the definition.
     * It is up to you to decide whether you simply update the supplied partial proof and add it to the presentation in the callback,
     * or whether you will use the selected Credentials, Presentation definition, evaluation results and/or presentation submission together with the signature opts
     *
     * @param presentationDefinition the Presentation Definition V1 or V2
     * @param selectedCredentials the PEX and/or User selected/filtered credentials that will become part of the Verifiable Presentation
     * @param signingCallBack the function which will be provided as a parameter. And this will be the method that will be able to perform actual
     *        signing. One example of signing is available in the project named. pe-selective-disclosure.
     * @param opts: Signing Params these are the signing params required to sign.
     *
     * @return the signed and thus Verifiable Presentation.
     */
    verifiablePresentationFrom(presentationDefinition, selectedCredentials, signingCallBack, opts) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { holderDID, signatureOptions, proofOptions } = opts;
            const presentationSubmissionLocation = (_a = opts.presentationSubmissionLocation) !== null && _a !== void 0 ? _a : signing_1.PresentationSubmissionLocation.PRESENTATION;
            function limitedDisclosureSuites() {
                let limitDisclosureSignatureSuites = [];
                if (proofOptions === null || proofOptions === void 0 ? void 0 : proofOptions.typeSupportsSelectiveDisclosure) {
                    if (!(proofOptions === null || proofOptions === void 0 ? void 0 : proofOptions.type)) {
                        throw Error('Please provide a proof type if you enable selective disclosure');
                    }
                    limitDisclosureSignatureSuites = [proofOptions.type];
                }
                return limitDisclosureSignatureSuites;
            }
            const holderDIDs = holderDID ? [holderDID] : [];
            const limitDisclosureSignatureSuites = limitedDisclosureSuites();
            const evaluationResult = this.evaluateCredentials(presentationDefinition, selectedCredentials, {
                holderDIDs,
                limitDisclosureSignatureSuites,
            });
            const presentationResult = this.presentationFrom(presentationDefinition, evaluationResult.verifiableCredential, Object.assign(Object.assign({}, opts), { presentationSubmissionLocation }));
            const evaluationResults = this.evaluatePresentation(presentationDefinition, presentationResult.presentation, { limitDisclosureSignatureSuites });
            if (!evaluationResults.value) {
                throw new Error('Could not get evaluation results from presentationResult');
            }
            const proof = {
                type: proofOptions === null || proofOptions === void 0 ? void 0 : proofOptions.type,
                verificationMethod: signatureOptions === null || signatureOptions === void 0 ? void 0 : signatureOptions.verificationMethod,
                created: (proofOptions === null || proofOptions === void 0 ? void 0 : proofOptions.created) ? proofOptions.created : new Date().toISOString(),
                proofPurpose: proofOptions === null || proofOptions === void 0 ? void 0 : proofOptions.proofPurpose,
                proofValue: signatureOptions === null || signatureOptions === void 0 ? void 0 : signatureOptions.proofValue,
                jws: signatureOptions === null || signatureOptions === void 0 ? void 0 : signatureOptions.jws,
                challenge: proofOptions === null || proofOptions === void 0 ? void 0 : proofOptions.challenge,
                nonce: proofOptions === null || proofOptions === void 0 ? void 0 : proofOptions.nonce,
                domain: proofOptions === null || proofOptions === void 0 ? void 0 : proofOptions.domain,
            };
            const callBackParams = {
                options: opts,
                presentation: presentationResult.presentation,
                presentationDefinition,
                selectedCredentials,
                proof,
                presentationSubmission: evaluationResults.value,
                evaluationResults,
            };
            const verifiablePresentation = yield signingCallBack(callBackParams);
            return {
                verifiablePresentation,
                presentationSubmissionLocation,
                presentationSubmission: evaluationResults.value,
            };
        });
    }
    static definitionVersionDiscovery(presentationDefinition) {
        return (0, utils_1.definitionVersionDiscovery)(presentationDefinition);
    }
}
exports.PEX = PEX;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUEVYLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL1BFWC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFZQSx1REFBMkM7QUFDM0MsNkNBQXlGO0FBRXpGLHVDQUFtSTtBQUNuSSxtQ0FBa0k7QUFDbEksbUNBQXFEO0FBQ3JELDZDQUE2STtBQUU3STs7R0FFRztBQUNILE1BQWEsR0FBRztJQUdkO1FBQ0Usd0tBQXdLO1FBQ3hLLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLG9DQUF1QixFQUFFLENBQUM7SUFDaEUsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxvQkFBb0IsQ0FDekIsc0JBQStDLEVBQy9DLFlBQTRELEVBQzVELElBTUM7UUFFRCxNQUFNLDhCQUE4QixHQUNsQyxDQUFBLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSw4QkFBOEIsTUFBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDLENBQUMsQ0FBQSxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsc0JBQXNCLE1BQUssU0FBUyxDQUFDO1FBQ3hJLE1BQU0sRUFBRSxHQUFvQyx1QkFBZSxDQUFDLGdDQUFnQyxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDckgsTUFBTSxnQkFBZ0IsR0FBbUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDbEcsTUFBTSxtQkFBbUIsR0FBa0MsdUJBQWUsQ0FBQyw0Q0FBNEMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzFJLE1BQU0sc0JBQXNCLEdBQUcsQ0FBQSxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsc0JBQXNCLEtBQUksbUJBQW1CLENBQUMsWUFBWSxDQUFDLHVCQUF1QixDQUFDO1FBQ3hILElBQUksQ0FBQyxzQkFBc0IsSUFBSSxDQUFDLDhCQUE4QixFQUFFO1lBQzlELE1BQU0sS0FBSyxDQUFDLHdGQUF3RixDQUFDLENBQUM7U0FDdkc7UUFFRCxNQUFNLFVBQVUsR0FBRyxtQkFBbUIsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQzVHLE1BQU0sV0FBVyxtQ0FDWixJQUFJLEtBQ1AsVUFBVTtZQUNWLHNCQUFzQjtZQUN0Qiw4QkFBOEIsR0FDL0IsQ0FBQztRQUVGLE1BQU0sTUFBTSxHQUFzQixJQUFJLENBQUMsd0JBQXdCLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDbkgsSUFBSSxNQUFNLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRTtZQUN0RCxNQUFNLHVCQUF1QixHQUFHLElBQUksb0NBQXVCLEVBQUUsQ0FBQztZQUM5RCxNQUFNLGFBQWEsR0FBa0IsdUJBQXVCLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDbEgsSUFBSSxhQUFhLENBQUMsNkJBQTZCLEtBQUssd0JBQU0sQ0FBQyxLQUFLLEVBQUU7Z0JBQ2hFLE1BQU0sQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO2FBQ3BCO1NBQ0Y7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLG1CQUFtQixDQUN4QixzQkFBK0MsRUFDL0MscUJBQXFELEVBQ3JELElBS0M7UUFFRCxNQUFNLDRCQUE0QixHQUNoQyx1QkFBZSxDQUFDLDRDQUE0QyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFFdEYsbUtBQW1LO1FBQ25LLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLG9DQUF1QixFQUFFLENBQUM7UUFDOUQsTUFBTSxFQUFFLEdBQW9DLHVCQUFlLENBQUMsZ0NBQWdDLENBQUMsc0JBQXNCLENBQUMsQ0FBQztRQUNySCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsd0JBQXdCLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSw0QkFBNEIsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5RixJQUFJLE1BQU0sQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFO1lBQ3RELE1BQU0sdUJBQXVCLEdBQUcsSUFBSSxvQ0FBdUIsRUFBRSxDQUFDO1lBQzlELE1BQU0sYUFBYSxHQUFrQix1QkFBdUIsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLDRCQUE0QixFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ2hILE1BQU0sQ0FBQyw2QkFBNkIsR0FBRyxhQUFhLENBQUMsNkJBQTZCLENBQUM7U0FDcEY7YUFBTTtZQUNMLE1BQU0sQ0FBQyw2QkFBNkIsR0FBRyx3QkFBTSxDQUFDLEtBQUssQ0FBQztTQUNyRDtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksVUFBVSxDQUNmLHNCQUErQyxFQUMvQyxxQkFBcUQsRUFDckQsSUFLQztRQUVELE1BQU0sd0JBQXdCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQztRQUNuRixNQUFNLEVBQUUsR0FBb0MsdUJBQWUsQ0FBQyxnQ0FBZ0MsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQ3JILG1LQUFtSztRQUNuSyxJQUFJLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxvQ0FBdUIsRUFBRSxDQUFDO1FBQzlELE9BQU8sSUFBSSxDQUFDLHdCQUF3QixDQUFDLFVBQVUsQ0FBQyxFQUFFLEVBQUUsdUJBQWUsQ0FBQyw0Q0FBNEMsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3BKLENBQUM7SUFFTSwwQkFBMEIsQ0FDL0Isc0JBQStDLEVBQy9DLG1CQUFtRDtRQUVuRCxNQUFNLEVBQUUsR0FBb0MsdUJBQWUsQ0FBQyxnQ0FBZ0MsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQ3JILE9BQU8sSUFBSSxDQUFDLHdCQUF3QixDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsdUJBQWUsQ0FBQyw0Q0FBNEMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7SUFDN0ksQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxnQkFBZ0IsQ0FDckIsc0JBQStDLEVBQy9DLG1CQUFtRCxFQUNuRCxJQUEyQjs7UUFFM0IsTUFBTSw4QkFBOEIsR0FBRyxNQUFBLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSw4QkFBOEIsbUNBQUksd0NBQThCLENBQUMsWUFBWSxDQUFDO1FBQzNILE1BQU0sc0JBQXNCLEdBQUcsSUFBSSxDQUFDLDBCQUEwQixDQUFDLHNCQUFzQixFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFDNUcsTUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDLHFCQUFxQixDQUFDLG1CQUFtQixrQ0FDN0QsSUFBSSxLQUNQLHNCQUFzQixFQUFFLDhCQUE4QixLQUFLLHdDQUE4QixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFDM0ksQ0FBQztRQUNILE9BQU87WUFDTCxZQUFZO1lBQ1osOEJBQThCO1lBQzlCLHNCQUFzQjtTQUN2QixDQUFDO0lBQ0osQ0FBQztJQUVNLE1BQU0sQ0FBQyxxQkFBcUIsQ0FDakMsbUJBQWtGLEVBQ2xGLElBSUM7O1FBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLFNBQVMsQ0FBQztRQUMvQixNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQUEsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLHVCQUF1QiwwQ0FBRSxJQUFJLENBQUM7WUFDN0QsQ0FBQyxDQUFDLENBQUEsTUFBQSxJQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsdUJBQXVCLDBDQUFFLElBQUksS0FBSSxFQUFFO1lBQzNDLENBQUMsQ0FBQyxDQUFBLE1BQUEsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLHVCQUF1QiwwQ0FBRSxJQUFJO2dCQUNyQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDO2dCQUNyQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ1AsTUFBTSxPQUFPLEdBQUcsQ0FBQSxNQUFBLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSx1QkFBdUIsMENBQUcsVUFBVSxDQUFDO1lBQ3pELENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDdkQsQ0FBQyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUM7Z0JBQzFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUM5QyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ1AsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsd0NBQXdDLENBQUMsRUFBRTtZQUMvRCxPQUFPLENBQUMsSUFBSSxDQUFDLHdDQUF3QyxDQUFDLENBQUM7U0FDeEQ7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFO1lBQzVDLElBQUksQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUNyQztRQUNELElBQUksSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLHNCQUFzQixFQUFFO1lBQ2hDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLHdCQUF3QixDQUFDLEVBQUU7Z0JBQzVDLElBQUksQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQzthQUNyQztZQUNELElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLGlFQUFpRSxDQUFDLEVBQUU7Z0JBQ3hGLE9BQU8sQ0FBQyxJQUFJLENBQUMsaUVBQWlFLENBQUMsQ0FBQzthQUNqRjtTQUNGO1FBQ0QsbUVBQ0ssSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLHVCQUF1QixLQUNoQyxVQUFVLEVBQUUsT0FBTyxFQUNuQixJQUFJO1lBQ0osTUFBTSxLQUNILENBQUMsQ0FBQyxDQUFDLENBQUEsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLHNCQUFzQixDQUFBLElBQUksRUFBRSx1QkFBdUIsRUFBRSxJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQyxLQUMvRixvQkFBb0IsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBOEIsSUFDckk7SUFDSixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLGtCQUFrQixDQUFDLHNCQUErQztRQUM5RSxNQUFNLE1BQU0sR0FBRyxJQUFBLGtDQUEwQixFQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDbEUsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2hCLE1BQU0sTUFBTSxDQUFDLEtBQUssQ0FBQztTQUNwQjtRQUNELE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUN0QixNQUFNLENBQUMsT0FBTyxLQUFLLGlCQUFTLENBQUMsRUFBRTtZQUM3QixDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztnQkFDZCxPQUFPLEVBQUUsSUFBSSx1Q0FBMEIsQ0FBQyxNQUFNLENBQUM7Z0JBQy9DLE1BQU0sRUFBRSx1QkFBZSxDQUFDLDZDQUE2QyxDQUFDLHNCQUFrRCxDQUFDO2FBQzFILENBQUM7WUFDSixDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztnQkFDZCxPQUFPLEVBQUUsSUFBSSx1Q0FBMEIsQ0FBQyxNQUFNLENBQUM7Z0JBQy9DLE1BQU0sRUFBRSx1QkFBZSxDQUFDLDJDQUEyQyxDQUFDLHNCQUFrRCxDQUFDO2FBQ3hILENBQUMsQ0FBQztRQUNQLE9BQU8sSUFBSSw2QkFBZ0IsRUFBRSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLGtCQUFrQixDQUFDLHNCQUE4QztRQUM3RSxPQUFPLElBQUksNkJBQWdCLEVBQUUsQ0FBQyxRQUFRLENBQUM7WUFDckM7Z0JBQ0UsT0FBTyxFQUFFLElBQUkscUNBQXdCLENBQUMsTUFBTSxDQUFDO2dCQUM3QyxNQUFNLEVBQUUsc0JBQXNCO2FBQy9CO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7O09BZ0JHO0lBQ1UsMEJBQTBCLENBQ3JDLHNCQUErQyxFQUMvQyxtQkFBbUQsRUFDbkQsZUFBbUksRUFDbkksSUFBb0M7OztZQUVwQyxNQUFNLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQztZQUUzRCxNQUFNLDhCQUE4QixHQUFHLE1BQUEsSUFBSSxDQUFDLDhCQUE4QixtQ0FBSSx3Q0FBOEIsQ0FBQyxZQUFZLENBQUM7WUFFMUgsU0FBUyx1QkFBdUI7Z0JBQzlCLElBQUksOEJBQThCLEdBQWEsRUFBRSxDQUFDO2dCQUNsRCxJQUFJLFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRSwrQkFBK0IsRUFBRTtvQkFDakQsSUFBSSxDQUFDLENBQUEsWUFBWSxhQUFaLFlBQVksdUJBQVosWUFBWSxDQUFFLElBQUksQ0FBQSxFQUFFO3dCQUN2QixNQUFNLEtBQUssQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFDO3FCQUMvRTtvQkFDRCw4QkFBOEIsR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDdEQ7Z0JBQ0QsT0FBTyw4QkFBOEIsQ0FBQztZQUN4QyxDQUFDO1lBRUQsTUFBTSxVQUFVLEdBQWEsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDMUQsTUFBTSw4QkFBOEIsR0FBRyx1QkFBdUIsRUFBRSxDQUFDO1lBQ2pFLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLHNCQUFzQixFQUFFLG1CQUFtQixFQUFFO2dCQUM3RixVQUFVO2dCQUNWLDhCQUE4QjthQUMvQixDQUFDLENBQUM7WUFFSCxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxzQkFBc0IsRUFBRSxnQkFBZ0IsQ0FBQyxvQkFBb0Isa0NBQ3pHLElBQUksS0FDUCw4QkFBOEIsSUFDOUIsQ0FBQztZQUNILE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLHNCQUFzQixFQUFFLGtCQUFrQixDQUFDLFlBQVksRUFBRSxFQUFFLDhCQUE4QixFQUFFLENBQUMsQ0FBQztZQUNqSixJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFO2dCQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUM7YUFDN0U7WUFFRCxNQUFNLEtBQUssR0FBb0I7Z0JBQzdCLElBQUksRUFBRSxZQUFZLGFBQVosWUFBWSx1QkFBWixZQUFZLENBQUUsSUFBSTtnQkFDeEIsa0JBQWtCLEVBQUUsZ0JBQWdCLGFBQWhCLGdCQUFnQix1QkFBaEIsZ0JBQWdCLENBQUUsa0JBQWtCO2dCQUN4RCxPQUFPLEVBQUUsQ0FBQSxZQUFZLGFBQVosWUFBWSx1QkFBWixZQUFZLENBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLFdBQVcsRUFBRTtnQkFDaEYsWUFBWSxFQUFFLFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRSxZQUFZO2dCQUN4QyxVQUFVLEVBQUUsZ0JBQWdCLGFBQWhCLGdCQUFnQix1QkFBaEIsZ0JBQWdCLENBQUUsVUFBVTtnQkFDeEMsR0FBRyxFQUFFLGdCQUFnQixhQUFoQixnQkFBZ0IsdUJBQWhCLGdCQUFnQixDQUFFLEdBQUc7Z0JBQzFCLFNBQVMsRUFBRSxZQUFZLGFBQVosWUFBWSx1QkFBWixZQUFZLENBQUUsU0FBUztnQkFDbEMsS0FBSyxFQUFFLFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRSxLQUFLO2dCQUMxQixNQUFNLEVBQUUsWUFBWSxhQUFaLFlBQVksdUJBQVosWUFBWSxDQUFFLE1BQU07YUFDN0IsQ0FBQztZQUVGLE1BQU0sY0FBYyxHQUFtQztnQkFDckQsT0FBTyxFQUFFLElBQUk7Z0JBQ2IsWUFBWSxFQUFFLGtCQUFrQixDQUFDLFlBQVk7Z0JBQzdDLHNCQUFzQjtnQkFDdEIsbUJBQW1CO2dCQUNuQixLQUFLO2dCQUNMLHNCQUFzQixFQUFFLGlCQUFpQixDQUFDLEtBQUs7Z0JBQy9DLGlCQUFpQjthQUNsQixDQUFDO1lBQ0YsTUFBTSxzQkFBc0IsR0FBRyxNQUFNLGVBQWUsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUVyRSxPQUFPO2dCQUNMLHNCQUFzQjtnQkFDdEIsOEJBQThCO2dCQUM5QixzQkFBc0IsRUFBRSxpQkFBaUIsQ0FBQyxLQUFLO2FBQ2hELENBQUM7O0tBQ0g7SUFFTSxNQUFNLENBQUMsMEJBQTBCLENBQUMsc0JBQStDO1FBQ3RGLE9BQU8sSUFBQSxrQ0FBMEIsRUFBQyxzQkFBc0IsQ0FBQyxDQUFDO0lBQzVELENBQUM7Q0FDRjtBQTlVRCxrQkE4VUMifQ==