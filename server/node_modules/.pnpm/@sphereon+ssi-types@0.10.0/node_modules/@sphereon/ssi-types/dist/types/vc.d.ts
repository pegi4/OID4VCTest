import { PresentationSubmission } from './pex';
import { IProofPurpose, IProofType } from './did';
export type AdditionalClaims = Record<string, any>;
export type IIssuerId = string;
export interface ICredential {
    '@context': ICredentialContextType | ICredentialContextType[];
    type: string[];
    credentialSchema?: undefined | ICredentialSchemaType | ICredentialSchemaType[];
    issuer: IIssuerId | IIssuer;
    issuanceDate: string;
    credentialSubject: (ICredentialSubject & AdditionalClaims) | (ICredentialSubject & AdditionalClaims)[];
    expirationDate?: string;
    id?: string;
    credentialStatus?: ICredentialStatus;
    description?: string;
    name?: string;
    [x: string]: any;
}
export interface ICredentialSubject {
    id?: string;
}
export type ICredentialContextType = (ICredentialContext & AdditionalClaims) | string;
export interface ICredentialContext {
    name?: string;
    did?: string;
}
export type ICredentialSchemaType = ICredentialSchema | string;
export interface ICredentialSchema {
    id: string;
    type?: string;
}
export interface IProof {
    type: IProofType | string;
    created: string;
    proofPurpose: IProofPurpose | string;
    verificationMethod: string;
    challenge?: string;
    domain?: string;
    proofValue?: string;
    jws?: string;
    jwt?: string;
    nonce?: string;
    requiredRevealStatements?: string[];
    [x: string]: any;
}
export interface ICredentialStatus {
    id: string;
    type: string;
}
export interface IIssuer {
    id: string;
    [x: string]: any;
}
export interface IHasProof {
    proof: IProof | IProof[];
}
export type IVerifiableCredential = ICredential & IHasProof;
/**
 * Represents a Json Web Token in compact form.
 */
export type CompactJWT = string;
/**
 * Represents a signed Verifiable Credential (includes proof), in either JSON or compact JWT format.
 * See {@link https://www.w3.org/TR/vc-data-model/#credentials | VC data model}
 * See {@link https://www.w3.org/TR/vc-data-model/#proof-formats | proof formats}
 */
export type W3CVerifiableCredential = IVerifiableCredential | CompactJWT;
export interface IPresentation {
    id?: string;
    '@context': ICredentialContextType | ICredentialContextType[];
    type?: string | string[];
    verifiableCredential?: W3CVerifiableCredential[];
    presentation_submission?: PresentationSubmission;
    holder?: string;
    verifier?: string;
    [x: string]: any;
}
export type IVerifiablePresentation = IPresentation & IHasProof;
/**
 * Represents a signed Verifiable Presentation (includes proof), in either JSON or compact JWT format.
 * See {@link https://www.w3.org/TR/vc-data-model/#presentations | VC data model}
 * See {@link https://www.w3.org/TR/vc-data-model/#proof-formats | proof formats}
 */
export type W3CVerifiablePresentation = IVerifiablePresentation | CompactJWT;
export interface WrappedVerifiableCredential {
    /**
     * Original VC that we've received
     */
    original: OriginalVerifiableCredential;
    /**
     * In case of JWT credential it will be the decoded version. In other cases it will be the same as original one
     */
    decoded: JwtDecodedVerifiableCredential | IVerifiableCredential;
    /**
     * Type of this credential. Supported types are json-ld and jwt (decoded/encoded)
     */
    type: OriginalType;
    /**
     * The claim format, typically used during exchange transport protocols
     */
    format: CredentialFormat;
    /**
     * Internal stable representation of a Credential
     */
    credential: IVerifiableCredential;
}
export interface WrappedVerifiablePresentation {
    /**
     * Original VP that we've received
     */
    original: OriginalVerifiablePresentation;
    /**
     * In case of JWT VP it will be the decoded version. In other cases it will be the same as original one
     */
    decoded: JwtDecodedVerifiablePresentation | IVerifiablePresentation;
    /**
     * Type of this Presentation. Supported types are json-ld and jwt (decoded/encoded)
     */
    type: OriginalType;
    /**
     * The claim format, typically used during exchange transport protocols
     */
    format: PresentationFormat;
    /**
     * Internal stable representation of a Presentation without proofs, created based on https://www.w3.org/TR/vc-data-model/#jwt-decoding
     */
    presentation: UniformVerifiablePresentation;
    /**
     * Wrapped Verifiable Credentials belonging to the Presentation
     */
    vcs: WrappedVerifiableCredential[];
}
export declare enum OriginalType {
    JSONLD = "json-ld",
    JWT_ENCODED = "jwt-encoded",
    JWT_DECODED = "jwt-decoded"
}
export interface UniformVerifiablePresentation {
    '@context': ICredentialContextType | ICredentialContextType[];
    type: string | string[];
    verifiableCredential: WrappedVerifiableCredential[];
    presentation_submission?: PresentationSubmission;
    holder?: string;
}
export interface JwtDecodedVerifiableCredential {
    vc: IVerifiableCredential;
    exp: string;
    iss: string;
    nbf: string;
    sub: string;
    jti: string;
    [x: string]: any;
}
export interface JwtDecodedVerifiablePresentation {
    vp: IVerifiablePresentation;
    exp: string;
    iss: string;
    nbf: string;
    sub: string;
    jti: string;
    aud: string;
    iat: string;
    [x: string]: any;
}
export type CredentialFormat = 'jwt' | 'ldp' | 'jwt_vc' | 'ldp_vc' | string;
export type PresentationFormat = 'jwt' | 'ldp' | 'jwt_vp' | 'ldp_vp' | string;
export type ClaimFormat = CredentialFormat | PresentationFormat;
export type OriginalVerifiableCredential = W3CVerifiableCredential | JwtDecodedVerifiableCredential;
export type OriginalVerifiablePresentation = W3CVerifiablePresentation | JwtDecodedVerifiablePresentation;
export type Original = OriginalVerifiablePresentation | OriginalVerifiableCredential;
export declare const enum DocumentFormat {
    JWT = 0,
    JSONLD = 1,
    EIP712 = 2
}
//# sourceMappingURL=vc.d.ts.map