"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialMapper = void 0;
const types_1 = require("../types");
const jwt_decode_1 = __importDefault(require("jwt-decode"));
const utils_1 = require("../utils");
class CredentialMapper {
    static decodeVerifiablePresentation(presentation) {
        var _a;
        if (CredentialMapper.isJwtEncoded(presentation)) {
            const payload = (0, jwt_decode_1.default)(presentation);
            const header = (0, jwt_decode_1.default)(presentation, { header: true });
            payload.vp.proof = {
                type: types_1.IProofType.JwtProof2020,
                created: payload.nbf,
                proofPurpose: types_1.IProofPurpose.authentication,
                verificationMethod: (_a = header['kid']) !== null && _a !== void 0 ? _a : payload.iss,
                jwt: presentation,
            };
            return payload;
        }
        else if (CredentialMapper.isJwtDecodedPresentation(presentation)) {
            return presentation;
        }
        else if (CredentialMapper.isJsonLdAsString(presentation)) {
            return JSON.parse(presentation);
        }
        else {
            return presentation;
        }
    }
    static decodeVerifiableCredential(credential) {
        var _a;
        if (CredentialMapper.isJwtEncoded(credential)) {
            const payload = (0, jwt_decode_1.default)(credential);
            const header = (0, jwt_decode_1.default)(credential, { header: true });
            payload.vc.proof = {
                type: types_1.IProofType.JwtProof2020,
                created: payload.nbf,
                proofPurpose: types_1.IProofPurpose.authentication,
                verificationMethod: (_a = header['kid']) !== null && _a !== void 0 ? _a : payload.iss,
                jwt: credential,
            };
            return payload;
        }
        else if (CredentialMapper.isJwtDecodedCredential(credential)) {
            return credential;
        }
        else if (CredentialMapper.isJsonLdAsString(credential)) {
            return JSON.parse(credential);
        }
        else {
            return credential;
        }
    }
    static toWrappedVerifiablePresentation(originalPresentation, opts) {
        const proof = CredentialMapper.getFirstProof(originalPresentation);
        const original = typeof originalPresentation !== 'string' && CredentialMapper.hasJWTProofType(originalPresentation) ? proof === null || proof === void 0 ? void 0 : proof.jwt : originalPresentation;
        if (!original) {
            throw Error('Could not determine original presentation, probably it was a converted JWT presentation, that is now missing the JWT value in the proof');
        }
        const decoded = CredentialMapper.decodeVerifiablePresentation(original);
        const isJwtEncoded = CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = CredentialMapper.isJwtDecodedPresentation(original);
        const type = isJwtEncoded ? types_1.OriginalType.JWT_ENCODED : isJwtDecoded ? types_1.OriginalType.JWT_DECODED : types_1.OriginalType.JSONLD;
        const format = isJwtDecoded || isJwtEncoded ? 'jwt_vp' : 'ldp_vp';
        let vp;
        if (isJwtEncoded || isJwtDecoded) {
            vp = CredentialMapper.jwtDecodedPresentationToUniformPresentation(decoded, false, opts);
        }
        else {
            vp = decoded;
        }
        if (!vp || !('verifiableCredential' in vp) || !vp.verifiableCredential || vp.verifiableCredential.length === 0) {
            throw Error(`VP needs to have at least one verifiable credential at this point`);
        }
        const vcs = CredentialMapper.toWrappedVerifiableCredentials(vp.verifiableCredential /*.map(value => value.original)*/, opts);
        const presentation = Object.assign(Object.assign({}, vp), { verifiableCredential: vcs });
        return {
            type,
            format,
            original,
            decoded,
            presentation,
            vcs,
        };
    }
    static toWrappedVerifiableCredentials(verifiableCredentials, opts) {
        return verifiableCredentials.map((vc) => CredentialMapper.toWrappedVerifiableCredential(vc, opts));
    }
    static toWrappedVerifiableCredential(verifiableCredential, opts) {
        var _a;
        const proof = CredentialMapper.getFirstProof(verifiableCredential);
        const original = CredentialMapper.hasJWTProofType(verifiableCredential) && proof ? (_a = proof.jwt) !== null && _a !== void 0 ? _a : verifiableCredential : verifiableCredential;
        if (!original) {
            throw Error('Could not determine original credential, probably it was a converted JWT credential, that is now missing the JWT value in the proof');
        }
        const decoded = CredentialMapper.decodeVerifiableCredential(original);
        const isJwtEncoded = CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = CredentialMapper.isJwtDecodedCredential(original);
        const type = isJwtEncoded ? types_1.OriginalType.JWT_ENCODED : isJwtDecoded ? types_1.OriginalType.JWT_DECODED : types_1.OriginalType.JSONLD;
        const credential = isJwtEncoded || isJwtDecoded
            ? CredentialMapper.jwtDecodedCredentialToUniformCredential(decoded, opts)
            : decoded;
        const format = isJwtEncoded || isJwtDecoded ? 'jwt_vc' : 'ldp_vc';
        return {
            original,
            decoded,
            format,
            type,
            credential,
        };
    }
    static isJwtEncoded(original) {
        return utils_1.ObjectUtils.isString(original) && original.startsWith('ey');
    }
    static isJsonLdAsString(original) {
        return utils_1.ObjectUtils.isString(original) && original.includes('@context');
    }
    static isJwtDecodedCredential(original) {
        return original['vc'] !== undefined && original['iss'] !== undefined;
    }
    static isJwtDecodedPresentation(original) {
        return original['vp'] !== undefined && original['iss'] !== undefined;
    }
    static jwtEncodedPresentationToUniformPresentation(jwt, makeCredentialsUniform = true, opts) {
        return CredentialMapper.jwtDecodedPresentationToUniformPresentation((0, jwt_decode_1.default)(jwt), makeCredentialsUniform, opts);
    }
    static jwtDecodedPresentationToUniformPresentation(decoded, makeCredentialsUniform = true, opts) {
        const { iss, aud, jti, vp } = decoded, rest = __rest(decoded, ["iss", "aud", "jti", "vp"]);
        const presentation = Object.assign(Object.assign({}, rest), vp);
        if (makeCredentialsUniform) {
            if (!vp.verifiableCredential) {
                throw Error('Verifiable Presentation should have a verifiable credential at this point');
            }
            presentation.verifiableCredential = vp.verifiableCredential.map((vc) => CredentialMapper.toUniformCredential(vc, opts));
        }
        if (iss) {
            const holder = presentation.holder;
            if (holder) {
                if (holder !== iss) {
                    throw new Error(`Inconsistent holders between JWT claim (${iss}) and VC value (${holder})`);
                }
            }
            presentation.holder = iss;
        }
        if (aud) {
            const verifier = presentation.verifier;
            if (verifier) {
                if (verifier !== aud) {
                    throw new Error(`Inconsistent holders between JWT claim (${aud}) and VC value (${verifier})`);
                }
            }
            presentation.verifier = aud;
        }
        if (jti) {
            const id = presentation.id;
            if (id && id !== jti) {
                throw new Error(`Inconsistent VP ids between JWT claim (${jti}) and VP value (${id})`);
            }
            presentation.id = jti;
        }
        return presentation;
    }
    static toUniformCredential(verifiableCredential, opts) {
        var _a;
        const original = typeof verifiableCredential !== 'string' && CredentialMapper.hasJWTProofType(verifiableCredential)
            ? (_a = CredentialMapper.getFirstProof(verifiableCredential)) === null || _a === void 0 ? void 0 : _a.jwt
            : verifiableCredential;
        if (!original) {
            throw Error('Could not determine original credential from passed in credential. Probably because a JWT proof type was present, but now is not available anymore');
        }
        const decoded = CredentialMapper.decodeVerifiableCredential(original);
        const isJwtEncoded = CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = CredentialMapper.isJwtDecodedCredential(original);
        if (isJwtDecoded || isJwtEncoded) {
            return CredentialMapper.jwtDecodedCredentialToUniformCredential(decoded, opts);
        }
        else {
            return decoded;
        }
    }
    static toUniformPresentation(presentation, opts) {
        var _a;
        const proof = CredentialMapper.getFirstProof(presentation);
        const original = typeof presentation !== 'string' && CredentialMapper.hasJWTProofType(presentation) ? proof === null || proof === void 0 ? void 0 : proof.jwt : presentation;
        if (!original) {
            throw Error('Could not determine original presentation, probably it was a converted JWT presentation, that is now missing the JWT value in the proof');
        }
        const decoded = CredentialMapper.decodeVerifiablePresentation(original);
        const isJwtEncoded = CredentialMapper.isJwtEncoded(original);
        const isJwtDecoded = CredentialMapper.isJwtDecodedPresentation(original);
        const uniformPresentation = isJwtEncoded || isJwtDecoded
            ? CredentialMapper.jwtDecodedPresentationToUniformPresentation(decoded, false)
            : decoded;
        // At time of writing Velocity Networks does not conform to specification. Adding bare minimum @context section to stop parsers from crashing and whatnot
        if ((opts === null || opts === void 0 ? void 0 : opts.addContextIfMissing) && !uniformPresentation['@context']) {
            uniformPresentation['@context'] = ['https://www.w3.org/2018/credentials/v1'];
        }
        uniformPresentation.verifiableCredential = (_a = uniformPresentation.verifiableCredential) === null || _a === void 0 ? void 0 : _a.map((vc) => CredentialMapper.toUniformCredential(vc, opts)); // We cast it because we IPresentation needs a VC. The internal Credential doesn't have the required Proof anymore (that is intended)
        return uniformPresentation;
    }
    static jwtEncodedCredentialToUniformCredential(jwt, opts) {
        return CredentialMapper.jwtDecodedCredentialToUniformCredential((0, jwt_decode_1.default)(jwt), opts);
    }
    static jwtDecodedCredentialToUniformCredential(decoded, opts) {
        const { exp, nbf, iss, vc, sub, jti } = decoded, rest = __rest(decoded, ["exp", "nbf", "iss", "vc", "sub", "jti"]);
        const credential = Object.assign(Object.assign({}, rest), vc);
        const maxSkewInMS = (opts === null || opts === void 0 ? void 0 : opts.maxTimeSkewInMS) !== undefined ? opts.maxTimeSkewInMS : 999;
        if (exp) {
            const expDate = credential.expirationDate;
            const jwtExp = parseInt(exp.toString());
            // fix seconds to millisecond for the date
            const expDateAsStr = jwtExp < 9999999999 ? new Date(jwtExp * 1000).toISOString().replace(/\.000Z/, 'Z') : new Date(jwtExp).toISOString();
            if (expDate && expDate !== expDateAsStr) {
                const diff = Math.abs(new Date(expDateAsStr).getTime() - new Date(expDate).getTime());
                if (!maxSkewInMS || diff > maxSkewInMS) {
                    throw new Error(`Inconsistent expiration dates between JWT claim (${expDateAsStr}) and VC value (${expDate})`);
                }
            }
            credential.expirationDate = expDateAsStr;
        }
        if (nbf) {
            const issuanceDate = credential.issuanceDate;
            const jwtNbf = parseInt(nbf.toString());
            // fix seconds to millisecs for the date
            const nbfDateAsStr = jwtNbf < 9999999999 ? new Date(jwtNbf * 1000).toISOString().replace(/\.000Z/, 'Z') : new Date(jwtNbf).toISOString();
            if (issuanceDate && issuanceDate !== nbfDateAsStr) {
                const diff = Math.abs(new Date(nbfDateAsStr).getTime() - new Date(issuanceDate).getTime());
                if (!maxSkewInMS || diff > maxSkewInMS) {
                    throw new Error(`Inconsistent issuance dates between JWT claim (${nbfDateAsStr}) and VC value (${issuanceDate})`);
                }
            }
            credential.issuanceDate = nbfDateAsStr;
        }
        if (iss) {
            const issuer = credential.issuer;
            if (issuer) {
                if (typeof issuer === 'string') {
                    if (issuer !== iss) {
                        throw new Error(`Inconsistent issuers between JWT claim (${iss}) and VC value (${issuer})`);
                    }
                }
                else {
                    if (issuer.id !== iss) {
                        throw new Error(`Inconsistent issuers between JWT claim (${iss}) and VC value (${issuer.id})`);
                    }
                }
            }
            else {
                credential.issuer = iss;
            }
        }
        if (sub) {
            const subjects = Array.isArray(credential.credentialSubject) ? credential.credentialSubject : [credential.credentialSubject];
            for (let i = 0; i < subjects.length; i++) {
                const csId = subjects[i].id;
                if (csId && csId !== sub) {
                    throw new Error(`Inconsistent credential subject ids between JWT claim (${sub}) and VC value (${csId})`);
                }
                Array.isArray(credential.credentialSubject) ? (credential.credentialSubject[i].id = sub) : (credential.credentialSubject.id = sub);
            }
        }
        if (jti) {
            const id = credential.id;
            if (id && id !== jti) {
                throw new Error(`Inconsistent credential ids between JWT claim (${jti}) and VC value (${id})`);
            }
            credential.id = jti;
        }
        return credential;
    }
    static toExternalVerifiableCredential(verifiableCredential) {
        let proof;
        if (verifiableCredential.proof) {
            if (!verifiableCredential.proof.type) {
                throw new Error('Verifiable credential proof is missing a type');
            }
            if (!verifiableCredential.proof.created) {
                throw new Error('Verifiable credential proof is missing a created date');
            }
            if (!verifiableCredential.proof.proofPurpose) {
                throw new Error('Verifiable credential proof is missing a proof purpose');
            }
            if (!verifiableCredential.proof.verificationMethod) {
                throw new Error('Verifiable credential proof is missing a verification method');
            }
            proof = Object.assign(Object.assign({}, verifiableCredential.proof), { type: verifiableCredential.proof.type, created: verifiableCredential.proof.created, proofPurpose: verifiableCredential.proof.proofPurpose, verificationMethod: verifiableCredential.proof.verificationMethod });
        }
        return Object.assign(Object.assign({}, verifiableCredential), { type: verifiableCredential.type
                ? typeof verifiableCredential.type === 'string'
                    ? [verifiableCredential.type]
                    : verifiableCredential.type
                : ['VerifiableCredential'], proof });
    }
    static storedCredentialToOriginalFormat(credential) {
        const type = CredentialMapper.detectDocumentType(credential);
        if (typeof credential === 'string') {
            if (type === 0 /* DocumentFormat.JWT */) {
                return CredentialMapper.toCompactJWT(credential);
            }
            else if (type === 1 /* DocumentFormat.JSONLD */) {
                return JSON.parse(credential);
            }
        }
        return credential;
    }
    static storedPresentationToOriginalFormat(presentation) {
        const type = CredentialMapper.detectDocumentType(presentation);
        if (typeof presentation === 'string') {
            if (type === 0 /* DocumentFormat.JWT */) {
                return CredentialMapper.toCompactJWT(presentation);
            }
            else if (type === 1 /* DocumentFormat.JSONLD */) {
                return JSON.parse(presentation);
            }
        }
        return presentation;
    }
    static toCompactJWT(jwtDocument) {
        if (CredentialMapper.detectDocumentType(jwtDocument) !== 0 /* DocumentFormat.JWT */) {
            throw Error('Cannot convert non JWT credential to JWT');
        }
        if (typeof jwtDocument === 'string') {
            return jwtDocument;
        }
        let proof;
        if ('vp' in jwtDocument) {
            proof = jwtDocument.vp.proof;
        }
        else if ('vc' in jwtDocument) {
            proof = jwtDocument.vc.proof;
        }
        else {
            proof = Array.isArray(jwtDocument.proof) ? jwtDocument.proof[0].jwt : jwtDocument.proof.jwt;
        }
        if (!proof) {
            throw Error(`Could not get JWT from supplied document`);
        }
        return proof;
    }
    static detectDocumentType(document) {
        if (typeof document === 'string') {
            return this.isJsonLdAsString(document) ? 1 /* DocumentFormat.JSONLD */ : 0 /* DocumentFormat.JWT */;
        }
        const proofs = 'vc' in document ? document.vc.proof : 'vp' in document ? document.vp.proof : document.proof;
        const proof = Array.isArray(proofs) ? proofs[0] : proofs;
        if (proof === null || proof === void 0 ? void 0 : proof.jwt) {
            return 0 /* DocumentFormat.JWT */;
        }
        else if ((proof === null || proof === void 0 ? void 0 : proof.type) === 'EthereumEip712Signature2021') {
            return 2 /* DocumentFormat.EIP712 */;
        }
        return 1 /* DocumentFormat.JSONLD */;
    }
    static hasJWTProofType(document) {
        var _a;
        if (typeof document === 'string') {
            return false;
        }
        return !!((_a = CredentialMapper.getFirstProof(document)) === null || _a === void 0 ? void 0 : _a.jwt);
    }
    static getFirstProof(document) {
        if (typeof document === 'string') {
            return undefined;
        }
        const proofs = 'vc' in document ? document.vc.proof : 'vp' in document ? document.vp.proof : document.proof;
        return Array.isArray(proofs) ? proofs[0] : proofs;
    }
}
exports.CredentialMapper = CredentialMapper;
//# sourceMappingURL=credential-mapper.js.map